0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.1 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P4.5 is pressed.
                  7   $LIST
0000              9   
0000             10   ; My adaptations
0000             11   ; 1. Changed the TIMER2_Rate to 500Hz, so that we trigger a timer2 intrupt every 2ms
0000             12   ;    this allows for a 1 second delay, since the count1ms counter triggers a display 
0000             13   ;         update every 500 interupts.
0000             14   
0000             15   ; There is a couple of typos in MODLP51 in the definition of the timer 0/1 reload
0000             16   ; special function registers (SFRs), so:
0000             17   
0000             18   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000             19   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             20   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             21   TIMER2_RATE   EQU 500   ; 500Hz, for a timer tick of 2ms (timer overflows and triggers an interupt every 2ms -> goes to ISR)
0000             22   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             23   
0000             24   HOURS_BUTTON   equ P0.6
0000             25   SECONDS_BUTTON equ P0.0
0000             26   MINUTES_BUTTON equ P0.3
0000             27   AMPM_BUTTON    equ P4.5
0000             28   CLOCK_MODE     equ p2.1 ; controls between clock and alarm
0000             29   SOUND_OUT     equ P1.1
0000             30   
0000             31   ; Reset vector
0000             32   org 0x0000
0000 020234      33       ljmp main
0003             34   
0003             35   ; External interrupt 0 vector (not used in this code)
0003             36   org 0x0003
0003 32          37            reti
0004             38   
0004             39   ; Timer/Counter 0 overflow interrupt vector
000B             40   org 0x000B
000B 020118      41            ljmp Timer0_ISR
000E             42   
000E             43   ; External interrupt 1 vector (not used in this code)
0013             44   org 0x0013
0013 32          45            reti
0014             46   
0014             47   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             48   org 0x001B
001B 32          49            reti
001C             50   
001C             51   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             52   org 0x0023 
0023 32          53            reti
0024             54            
0024             55   ; Timer/Counter 2 overflow interrupt vector
002B             56   org 0x002B
002B 020181      57            ljmp Timer2_ISR
002E             58   
002E             59   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             60   dseg at 0x30
0030             61   Count2ms:     ds 2 ; Used to determine when half second has passed (2 bytes)
0032             62   seconds:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop (1 byte -> 8 bits)
0033             63   minutes:  ds 1 ; counter to keep track of minutes
0034             64   hours:    ds 1 ; counter to keep track of hours
0035             65   minutes_A:  ds 1 ; counter to keep track of minutes on alarm
0036             66   hours_A:    ds 1 ; counter to keep track of hours on alarm
0037             67   
0037             68   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0037             69   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             70   bseg
0000             71   one_second_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             72   AMPM_flag: dbit 1 ; flag for if we are in AM or PM time
0002             73   Alarm_Clock_flag: dbit 1 ;flag for modifying alarm or clock values (Alarm_Clock_flag = 1 means we can set an alarm)
0003             74   AMPM_flag_A: dbit 1
0004             75   AMPM_flag_A_set: dbit 1
0005             76   Alarm_mode: dbit 1
0006             77   Alarm_active: dbit 1
0007             78   
002E             79   cseg
002E             80   ; These 'equ' must match the hardware wiring
002E             81   LCD_RS equ P3.2
002E             82   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E             83   LCD_E  equ P3.3
002E             84   LCD_D4 equ P3.4
002E             85   LCD_D5 equ P3.5
002E             86   LCD_D6 equ P3.6
002E             87   LCD_D7 equ P3.7
002E             88   
                 90   	$LIST
00DA             92   
00DA             93   ;                     1234567890123456    <- This helps determine the location of the counter
00DA 54696D65    94   Time_Message:  db    'Time  xx:xx:xx ', 0
     20207878
     3A78783A
     78782000
00EA 416C6172    95   Alarm_Message: db    'Alarm xx:xx ',0
     6D207878
     3A787820
     00
00F7 6F6E2000    96   Alarm_On:      db    'on ', 0
00FB 6F666600    97   Alarm_Off:     db    'off', 0
00FF             98   
00FF             99   ;---------------------------------;
00FF            100   ; Routine to initialize the ISR   ;
00FF            101   ; for timer 0                     ;
00FF            102   ;---------------------------------;
00FF            103   Timer0_Init:
00FF E589       104            mov a, TMOD
0101 54F0       105            anl a, #0xf0 ; Clear the bits for timer 0
0103 4401       106            orl a, #0x01 ; Configure timer 0 as 16-timer
0105 F589       107            mov TMOD, a
0107 758CEA     108            mov TH0, #high(TIMER0_RELOAD)
010A 758AE8     109            mov TL0, #low(TIMER0_RELOAD)
010D            110            ; Set autoreload value
010D 75F4EA     111            mov RH0, #high(TIMER0_RELOAD)
0110 75F2E8     112            mov RL0, #low(TIMER0_RELOAD)
0113            113            ; Enable the timer and interrupts
0113 C2A9       114       clr ET0  ; disable timer 0 interrupt (we will do turn this on when the alarm triggers)
0115 D28C       115       setb TR0  ; Start timer 0
0117 22         116            ret
0118            117   
0118            118   ;---------------------------------;
0118            119   ; ISR for timer 0.  Set to execute;
0118            120   ; every 1/4096Hz to generate a    ;
0118            121   ; 2048 Hz square wave at pin P1.1 ;
0118            122   ;---------------------------------;
0118            123   Timer0_ISR:
0118            124            ;clr TF0  ; According to the data sheet this is done for us already.
0118 B291       125            cpl SOUND_OUT ; Connect speaker to P1.1 -> complements this pin on and off every 
011A 32         126            reti
011B            127   
011B            128   ;---------------------------------;
011B            129   ; Routine to initialize the ISR   ;
011B            130   ; for timer 2                     ;
011B            131   ;---------------------------------;
011B            132   Timer2_Init:
011B 75C800     133            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
011E 75CD53     134            mov TH2, #high(TIMER2_RELOAD)
0121 75CC34     135            mov TL2, #low(TIMER2_RELOAD)
0124            136            ; Set the reload value
0124 75CB53     137            mov RCAP2H, #high(TIMER2_RELOAD)
0127 75CA34     138            mov RCAP2L, #low(TIMER2_RELOAD)
012A            139            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
012A E4         140            clr a
012B F530       141            mov Count2ms+0, a
012D F531       142            mov Count2ms+1, a
012F            143            ; Enable the timer and interrupts
012F D2AD       144       setb ET2  ; Enable timer 2 interrupt
0131 D2CA       145       setb TR2  ; Enable timer 2
0133 22         146            ret
0134            147   change_AMPM_A: ; label to update AMPM flag for the alarm row
0134 C0E0       148            push acc
0136 740C       148            mov a, #12
0138 14         148            dec a
0139 1200BD     148            lcall ?Set_Cursor_2 ; Select column and row
013C D0E0       148            pop acc
013E 30040C     149            jnb AMPM_flag_A_set, write_AM_A ; if current flag is PM, update to AM
0141 C0E0       150            push acc
0143 7450       150            mov a, #'P'
0145 12007E     150            lcall ?WriteData
0148 D0E0       150            pop acc ; else, curruent flag was AM, update to PM
014A C204       151            clr AMPM_flag_A_set
014C 22         152            ret
014D            153            write_AM_A:
014D C0E0       154            push acc
014F 7441       154            mov a, #'A'
0151 12007E     154            lcall ?WriteData
0154 D0E0       154            pop acc
0156 D204       155                    setb AMPM_flag_A_set
0158 22         156                    ret
0159            157   change_AMPM:
0159 3003D8     158            jnb AMPM_flag_A, change_AMPM_A ; if we are in "ALARM" mode, we should change the AM/PM type for the second row (jump to AMPM_A label)
015C C0E0       159            push acc
015E 7410       159            mov a, #16
0160 14         159            dec a
0161 1200BF     159            lcall ?Set_Cursor_1 ; Select column and row
0164 D0E0       159            pop acc ; otherwise, change the AM/PM type for the first row
0166 30010C     160            jnb AMPM_flag, write_AM ; if current flag is PM, update to AM
0169 C0E0       161            push acc
016B 7450       161            mov a, #'P'
016D 12007E     161            lcall ?WriteData
0170 D0E0       161            pop acc ; else, current flag was AM, update to PM
0172 C201       162       clr AMPM_flag
0174 22         163       ret
0175            164            write_AM:
0175 C0E0       165            push acc
0177 7441       165            mov a, #'A'
0179 12007E     165            lcall ?WriteData
017C D0E0       165            pop acc
017E D201       166            setb AMPM_flag
0180 22         167            ret
0181            168   ;---------------------------------;
0181            169   ; ISR for timer 2                 ;
0181            170   ;---------------------------------;
0181            171   ; In this subroutine, we can check our "alarm flag (to be created)" if our alarm is off or on
0181            172   ; If alarm is on, we need to somehow compare the current time with the alarm time, and trigger a 
0181            173   ; call to another subroutine that will activate the alarm and use the speaker 
0181            174   ; until we push the button that turns the alarm off. 
0181            175   Timer2_ISR: ;triggers when timer has overflowed (occurs after 2ms)
0181 C2CF       176            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0183 B290       177            cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0185            178            
0185            179            ; The two registers used in the ISR must be saved in the stack
0185 C0E0       180            push acc ; push accumulator to stack
0187 C0D0       181            push psw ; push status flag to stack
0189            182            
0189            183            ; Increment the 16-bit one mili second counter
0189 0530       184            inc Count2ms+0    ; Increment the low 8-bits first
018B E530       185            mov a, Count2ms+0 ; If the low 8-bits overflow, then increment high 8-bits
018D 7002       186            jnz Inc_Done
018F 0531       187            inc Count2ms+1
0191            188   
0191            189   Inc_Done:
0191            190            ; Check if half second has passed
0191 E530       191            mov a, Count2ms+0
0193 B4F430     192            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0196 E531       193            mov a, Count2ms+1
0198 B4012B     194            cjne a, #high(500), Timer2_ISR_done
019B            195            
019B            196            ; 500 milliseconds have passed.  Set a flag so the main program knows
019B D200       197            setb one_second_flag ; Let the main program know one second had passed
019D B28C       198            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
019F            199            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
019F E4         200            clr a
01A0            201            ;reset the 2ms counter
01A0 F530       202            mov Count2ms+0, a 
01A2 F531       203            mov Count2ms+1, a
01A4            204            ; Increment the seconds counter by 1
01A4 1201F4     205            lcall Update_Seconds
01A7 B4601C     206            cjne a, #0x60, Timer2_ISR_done ; check if seconds has reached 60 (if not 60, jump to Timer2_ISR_done)
01AA            207            
01AA            208   Update_Times: ;update all times subroutine (will trigger if we have reached a 60 seconds mark
01AA E4         209            clr a
01AB F532       210            mov seconds, a ;reset seconds to 0
01AD 1201FC     211            lcall Update_Minutes ; update minutes call
01B0 E533       212            mov a, minutes
01B2 B46011     213            cjne a, #0x60, Timer2_ISR_done ; check if minutes has reached 60 (if not 60, skip to Timer2_ISR_done)
01B5 E4         214            clr a
01B6 F533       215            mov minutes, a ; reset minutes to 0
01B8 120218     216            lcall Update_Hours ; update hours call
01BB E534       217            mov a, hours
01BD B41306     218            cjne a, #0x13, Timer2_ISR_done ; check if hours was at 12:00 when we reached 60 minutes(if not, goto Timer2_ISR_done)
01C0 753401     219            mov hours, #0x01 ; reset hours back to 1:00 if it was at 12:00 when we reached 60 minutes
01C3 120159     220            lcall change_AMPM ; if hours has gone over 12:00, we need to change the AMPM flag
01C6            221            
01C6            222   Timer2_ISR_done:
01C6            223            ; after all our relevant times have updated, we should compare the current time with the alarm time if the alarm is active
01C6 300526     224            jnb Alarm_mode, real_done ; if Alarm_mode is off, we skip to Timer2_ISR_done
01C9 E533       225            mov a, minutes
01CB B53521     226            cjne a, minutes_A, real_done ; if minutes_clock != minutes_A skip to Timer2_ISR_done, else check hours next
01CE E534       227            mov a, hours
01D0 B5361C     228            cjne a, hours_A, real_done ; if hours_clock != hours_A skips to TImer2_ISR_done, else check if AM/PM matches
01D3 200109     229            jb AMPM_flag, check1 ; if AMPM_flag = 1, check if AMPM_flag_A_set also is 1 (that means bboth alarm and clock are in AM)
01D6 30010F     230            jnb AMPM_flag, check2 ; if AMPM_flag = 0, check if AMPM_flag_A_set also is 0 (that means bboth alarm and clock are in PM)
01D9            231            ; if AM/PM on the clock != AM/PM on the alarm, times are not equal so skip to done
01D9            232            ; if we made it here, the clock time equals the alarm time, so that means we need to sound the alarm
01D9 D206       233            setb Alarm_active ; turn on the alarm active flag
01DB D2A9       234            setb ET0 ; enable Timer_0 interrupt -> this will cause our alarm to go off
01DD 8010       235            sjmp real_done
01DF            236            check1:
01DF 30040D     237                    jnb AMPM_flag_A_set, real_done ; if AMPM_flag_A_set = 0, that means clock is in AM, alarm is in PM, so goto real_done
01E2 D206       238                    setb Alarm_active ; else, trigger alarm
01E4 D2A9       239                    setb ET0
01E6 8007       240                    sjmp real_done
01E8            241            check2: 
01E8 200404     242                    jb AMPM_flag_A_set, real_done ;if AMPM_flag_A_set = 1, that means clock is in PM, alarm is in AM, so goto real_done
01EB D206       243                    setb Alarm_active ; else, trigger alarm
01ED D2A9       244                    setb ET0
01EF            245            real_done:
01EF D0D0       246                    pop psw
01F1 D0E0       247                    pop acc
01F3 32         248                    reti ;return from the interupt
01F4            249            
01F4            250   Update_Seconds:
01F4 E532       251            mov a, seconds
01F6 2401       252            add a, #0x01
01F8 D4         253            da a ;value in a -> BCD
01F9 F532       254            mov seconds, a ; seconds = BCD value
01FB 22         255            ret
01FC            256            
01FC            257   Update_Minutes:  ; updates either clock or alarm minute value
01FC 300211     258            jnb Alarm_Clock_flag, Minutes_Clock ; if not in alarm mode, update the clock time values
01FF E535       259            mov a, minutes_A ; else, update the alarm values
0201 2401       260            add a, #0x01
0203 D4         261            da a ;value in a -> BCD
0204 F535       262            mov minutes_A, a ; seconds = BCD value
0206 B46006     263            cjne a, #0x60, minute_A_done ; check if our alarm_minutes value has gone over 60 (if not, skip to minute_A_done)
0209 753500     264            mov minutes_A, #0x00 ; else, reset minute_A, and update the hours
020C 120218     265            lcall Update_Hours
020F            266            minute_A_done:
020F 22         267                    ret
0210            268            Minutes_Clock:
0210 E533       269                    mov a, minutes ; check minutes
0212 2401       270                    add a, #0x01 ; increment minutes by 1
0214 D4         271                    da a 
0215 F533       272                    mov minutes, a  
0217 22         273                    ret
0218            274   Update_Hours: ; updates either clock or alarm hour value
0218 300211     275            jnb Alarm_Clock_flag, Hours_Clock ; if not in alarm mode, update the clock hour values
021B E536       276            mov a, hours_A
021D 2401       277            add a, #0x01
021F D4         278            da a ;value in a -> BCD
0220 F536       279            mov hours_A, a ; seconds = BCD value
0222 B41306     280            cjne a, #0x13, hours_A_done
0225 753601     281            mov hours_A, #0x01
0228 120159     282            lcall change_AMPM ; if we have gone over 12 hours, we need to change AM/PM
022B            283            
022B            284            hours_A_done:
022B 22         285                    ret
022C            286            Hours_Clock:
022C E534       287                    mov a, hours
022E 2401       288                    add a, #0x01 ; increment hours by 1
0230 D4         289                    da a
0231 F534       290                    mov hours, a
0233 22         291                    ret
0234            292            
0234            293   ;---------------------------------;
0234            294   ; Main program. Includes hardware ;
0234            295   ; initialization and 'forever'    ;
0234            296   ; loop.                           ;
0234            297   ;---------------------------------;
0234            298   main:
0234            299            ; Initialization
0234 75817F     300       mov SP, #0x7F
0237 1200FF     301       lcall Timer0_Init
023A 12011B     302       lcall Timer2_Init
023D            303       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
023D 75E600     304       mov P0M0, #0
0240 75E700     305       mov P0M1, #0
0243 D2C5       306       setb p4.5
0245 D2AF       307       setb EA   ; Enable Global interrupts
0247 120088     308       lcall LCD_4BIT
024A            309       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
024A C0E0       310            push acc
024C 7401       310            mov a, #1
024E 14         310            dec a
024F 1200BF     310            lcall ?Set_Cursor_1 ; Select column and row
0252 D0E0       310            pop acc
0254 C083       311            push dph
0256 C082       311            push dpl
0258 C0E0       311            push acc
025A 9000DA     311            mov dptr, #Time_Message
025D 1200B2     311            lcall ?Send_Constant_String
0260 D0E0       311            pop acc
0262 D082       311            pop dpl
0264 D083       311            pop dph
0266 C0E0       312            push acc
0268 7401       312            mov a, #1
026A 14         312            dec a
026B 1200BD     312            lcall ?Set_Cursor_2 ; Select column and row
026E D0E0       312            pop acc
0270 C083       313            push dph
0272 C082       313            push dpl
0274 C0E0       313            push acc
0276 9000EA     313            mov dptr, #Alarm_Message
0279 1200B2     313            lcall ?Send_Constant_String
027C D0E0       313            pop acc
027E D082       313            pop dpl
0280 D083       313            pop dph
0282 C0E0       314            push acc
0284 7410       314            mov a, #16
0286 14         314            dec a
0287 1200BF     314            lcall ?Set_Cursor_1 ; Select column and row
028A D0E0       314            pop acc
028C C0E0       315            push acc
028E 7441       315            mov a, #'A'
0290 12007E     315            lcall ?WriteData
0293 D0E0       315            pop acc
0295 C0E0       316            push acc
0297 740C       316            mov a, #12
0299 14         316            dec a
029A 1200BD     316            lcall ?Set_Cursor_2 ; Select column and row
029D D0E0       316            pop acc
029F C0E0       317            push acc
02A1 7441       317            mov a, #'A'
02A3 12007E     317            lcall ?WriteData
02A6 D0E0       317            pop acc
02A8 C0E0       318            push acc
02AA 740E       318            mov a, #14
02AC 14         318            dec a
02AD 1200BD     318            lcall ?Set_Cursor_2 ; Select column and row
02B0 D0E0       318            pop acc
02B2 C083       319            push dph
02B4 C082       319            push dpl
02B6 C0E0       319            push acc
02B8 9000FB     319            mov dptr, #Alarm_off
02BB 1200B2     319            lcall ?Send_Constant_String
02BE D0E0       319            pop acc
02C0 D082       319            pop dpl
02C2 D083       319            pop dph ; initially display that the alarm is turned off
02C4 D200       320       setb one_second_flag
02C6 D201       321       setb AMPM_flag
02C8 D203       322       setb AMPM_flag_A
02CA D204       323       setb AMPM_flag_A_set
02CC C202       324       clr Alarm_Clock_flag ; alarm clock flag initially set to zero
02CE C205       325       clr Alarm_mode ; alarm should be automatically set to off
02D0 C206       326       clr Alarm_active ; make sure alarm is not active
02D2 753200     327            mov seconds, #0x00 ;initialize seconds to zero
02D5 753300     328            mov minutes, #0x00 ;initialize minutes to zero
02D8 753400     329            mov hours, #0x00 ;initialize hours to zero
02DB 753500     330            mov minutes_A, #0x00
02DE 753600     331            mov hours_A, #0x00
02E1            332   
02E1            333   Alarm_OnOff: ; defaults to alarm OFF after passing through the main initialization loop
02E1 30024C     334            jnb Alarm_Clock_flag, loop ; if we enter here after main, makes sure alarm is kept off and skip to loop
02E4 300523     335            jnb Alarm_mode, turn_A_on ; if Alarm_mode is zero (off) we want to turn it on
02E7 B205       336                    cpl Alarm_mode ; else, we turn off Alarm_mode
02E9 C0E0       337            push acc
02EB 740E       337            mov a, #14
02ED 14         337            dec a
02EE 1200BD     337            lcall ?Set_Cursor_2 ; Select column and row
02F1 D0E0       337            pop acc
02F3 C083       338            push dph
02F5 C082       338            push dpl
02F7 C0E0       338            push acc
02F9 9000FB     338            mov dptr, #Alarm_Off
02FC 1200B2     338            lcall ?Send_Constant_String
02FF D0E0       338            pop acc
0301 D082       338            pop dpl
0303 D083       338            pop dph ; write 'off' in the alarm field
0305 200622     339                    jb Alarm_active, turn_off_alarm ; if the alarm is actively sounding, we want to turn it off once we turn off Alarm_mode
0308 8058       340                    sjmp check_hours_push ; jump back to the next stage in our button daisy chain
030A            341            turn_A_on:
030A B205       342                    cpl Alarm_mode ; set Alarm_mode to 1
030C C0E0       343            push acc
030E 740E       343            mov a, #14
0310 14         343            dec a
0311 1200BD     343            lcall ?Set_Cursor_2 ; Select column and row
0314 D0E0       343            pop acc
0316 C083       344            push dph
0318 C082       344            push dpl
031A C0E0       344            push acc
031C 9000F7     344            mov dptr, #Alarm_On
031F 1200B2     344            lcall ?Send_Constant_String
0322 D0E0       344            pop acc
0324 D082       344            pop dpl
0326 D083       344            pop dph ; write 'on' in the alarm field
0328 8038       345                    sjmp check_hours_push ; jump back to the next stage in our button daisy chain
032A            346   turn_off_alarm: ; sub-routine that turns off the active alarm by complementing the ET0 (timer 0 interrupt)
032A C2A9       347            clr ET0 ; turn off timer_0 interrupt, which will stop the noise
032C C206       348            clr Alarm_active ; turn off the active alarm flag
032E 8032       349            sjmp check_hours_push ; resume button checking
0330            350   loop: ; After initialization the program stays in this 'forever' loop
0330 20802F     351            jb SECONDS_BUTTON, check_hours_push  ; if the 'BOOT' button is not pressed goto loop_a
0333 C002       352            push AR2
0335 7A32       352            mov R2, #50
0337 120039     352            lcall ?Wait_Milli_Seconds
033A D002       352            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
033C 208023     353            jb SECONDS_BUTTON, check_hours_push  ; if the 'BOOT' button is not pressed, goto loop_a 
033F 3080FD     354            jnb SECONDS_BUTTON, $     
0342 20029C     355            jb Alarm_Clock_flag, Alarm_OnOff ; if we are in alarm mode and the seconds button is pressed, toggle alarm on/off
0345            356   second_push: ; change second value from p0.0 pushbutton
0345 1201F4     357            lcall Update_Seconds ; increments seconds by 1
0348 B4606A     358            cjne a, #0x60, loop_b ; if seconds != 60, display all time values
034B 753200     359            mov seconds, #0x00
034E 1201FC     360            lcall Update_Minutes ; else, reset seconds to 0 and update minutes
0351 B46061     361            cjne a, #0x60, loop_b ; if minutes != 60, display all time values
0354 120218     362            lcall Update_Hours ; else, update the hours and reset minutes to 0
0357 B4135B     363            cjne a, #0x13, loop_b ; check if hours was at 12:00 when we reached 60 minutes(if not, goto Timer2_ISR_done)
035A 753401     364            mov hours, #0x01 ; reset hours back to 1:00 if it was at 12:00 when we reached 60 minutes
035D 120159     365            lcall change_AMPM
0360 8053       366            sjmp loop_b             ; Display the new value
0362            367   check_hours_push: ; change hour value from p0.6 pushbutton
0362 208625     368            jb HOURS_BUTTON, check_minutes_push  ; if the 'BOOT' button is not pressed goto loop_a
0365 C002       369            push AR2
0367 7A32       369            mov R2, #50
0369 120039     369            lcall ?Wait_Milli_Seconds
036C D002       369            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
036E 208619     370            jb HOURS_BUTTON, check_minutes_push  ; if the 'BOOT' button is not pressed, goto loop_a 
0371 3086FD     371            jnb HOURS_BUTTON, $        
0374            372   hour_push:
0374 120218     373            lcall Update_Hours
0377 E534       374            mov a, hours
0379 B41339     375            cjne a, #0x13, loop_b
037C 753401     376            mov hours, #0x01
037F 120159     377            lcall change_AMPM
0382 8031       378            sjmp loop_b
0384            379   loop_a: ; maximum distance from loop label for jnb to work
0384 3000A9     380            jnb one_second_flag, loop
0387 0203B5     381            ljmp loop_b
038A            382   check_minutes_push: ; change minute values from p0.3 pushbutton
038A 208330     383            jb MINUTES_BUTTON, check_AMPM_push  ; if the 'BOOT' button is not pressed goto loop_a
038D C002       384            push AR2
038F 7A32       384            mov R2, #50
0391 120039     384            lcall ?Wait_Milli_Seconds
0394 D002       384            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0396 208324     385            jb MINUTES_BUTTON, check_AMPM_push  ; if the 'BOOT' button is not pressed, goto loop_a 
0399 3083FD     386            jnb MINUTES_BUTTON, $      
039C            387   minute_push:
039C 1201FC     388            lcall Update_Minutes
039F E533       389            mov a, minutes
03A1 B46011     390            cjne a, #0x60, loop_b
03A4 753300     391            mov minutes, #0x00
03A7 120218     392            lcall Update_Hours
03AA B41308     393            cjne a, #0x13, loop_b
03AD 753401     394            mov hours, #0x01
03B0 120159     395            lcall change_AMPM
03B3 8000       396            sjmp loop_b
03B5            397            
03B5            398   ; we should control whether or not we change the clock vs. alarm digits in this loop
03B5            399   ; probably need to have an alarm flag (on/off) that will control which line we edit (clock/alarm)
03B5            400   ; we also probably need seperate counters for minutes and hours
03B5            401   loop_b: ;if one_second flag is high or we have reset the clock values, we enter this loop
03B5 C200       402       clr one_second_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
03B7 1203EC     403       lcall write_times ; prints all times to the display
03BA 020330     404       ljmp loop
03BD            405      
03BD            406   check_AMPM_push: ; change between AM/PM using p4.5 pushbutton
03BD 20C514     407            jb AMPM_BUTTON, check_mode_push  ; if the 'BOOT' button is not pressed goto loop_a
03C0 C002       408            push AR2
03C2 7A32       408            mov R2, #50
03C4 120039     408            lcall ?Wait_Milli_Seconds
03C7 D002       408            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03C9 20C508     409            jb AMPM_BUTTON, check_mode_push  ; if the 'BOOT' button is not pressed, goto loop_a 
03CC 30C5FD     410            jnb AMPM_BUTTON, $         ; Wait for button release.  The '$' means: jump to same instruction
03CF            411   AMPM_push:
03CF 120159     412            lcall change_AMPM
03D2 80E1       413            sjmp loop_b
03D4            414   check_mode_push: ; change between clock/alarm value editing mode using p2.1 pushbutton
03D4 20A1AD     415            jb CLOCK_MODE, loop_a  ; if the 'BOOT' button is not pressed goto loop_a
03D7 C002       416            push AR2
03D9 7A32       416            mov R2, #50
03DB 120039     416            lcall ?Wait_Milli_Seconds
03DE D002       416            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03E0 20A1A1     417            jb CLOCK_MODE, loop_a  ; if the 'BOOT' button is not pressed, goto loop_a 
03E3 30A1FD     418            jnb CLOCK_MODE, $          ; Wait for button release.  The '$' means: jump to same instruction
03E6            419   mode_push:
03E6 B202       420            cpl Alarm_Clock_flag ; triggers if we switch to "alarm" or "clock" editing mode
03E8 B203       421            cpl AMPM_flag_A ; flag to allow us to control the AM and PM setting in the ALARM row
03EA            422            ;cpl ET2  ; Disable/Enable timer 2 interrupt
03EA 80C9       423            sjmp loop_b
03EC            424   write_times: ; label to write all relevant time values to the LCD
03EC C0E0       425            push acc
03EE 740D       425            mov a, #13
03F0 14         425            dec a
03F1 1200BF     425            lcall ?Set_Cursor_1 ; Select column and row
03F4 D0E0       425            pop acc     ; the place in the LCD where we want the BCD counter value
03F6 C000       426            push ar0
03F8 A832       426            mov r0, seconds
03FA 1200C4     426            lcall ?Display_BCD
03FD D000       426            pop ar0 ; This macro is also in 'LCD_4bit.inc'
03FF C0E0       427            push acc
0401 740A       427            mov a, #10
0403 14         427            dec a
0404 1200BF     427            lcall ?Set_Cursor_1 ; Select column and row
0407 D0E0       427            pop acc
0409 C000       428            push ar0
040B A833       428            mov r0, minutes
040D 1200C4     428            lcall ?Display_BCD
0410 D000       428            pop ar0
0412 C0E0       429            push acc
0414 7407       429            mov a, #7
0416 14         429            dec a
0417 1200BF     429            lcall ?Set_Cursor_1 ; Select column and row
041A D0E0       429            pop acc
041C C000       430            push ar0
041E A834       430            mov r0, hours
0420 1200C4     430            lcall ?Display_BCD
0423 D000       430            pop ar0
0425 C0E0       431            push acc
0427 7407       431            mov a, #7
0429 14         431            dec a
042A 1200BD     431            lcall ?Set_Cursor_2 ; Select column and row
042D D0E0       431            pop acc
042F C000       432            push ar0
0431 A836       432            mov r0, hours_A
0433 1200C4     432            lcall ?Display_BCD
0436 D000       432            pop ar0
0438 C0E0       433            push acc
043A 740A       433            mov a, #10
043C 14         433            dec a
043D 1200BD     433            lcall ?Set_Cursor_2 ; Select column and row
0440 D0E0       433            pop acc
0442 C000       434            push ar0
0444 A835       434            mov r0, minutes_A
0446 1200C4     434            lcall ?Display_BCD
0449 D000       434            pop ar0
044B 22         435            ret
044C            436       
044C            437   END

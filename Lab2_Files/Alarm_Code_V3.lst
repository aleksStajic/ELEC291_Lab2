0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.1 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P4.5 is pressed.
                  7   $LIST
0000              9   
0000             10   ; My adaptations
0000             11   ; 1. Changed the TIMER2_Rate to 500Hz, so that we trigger a timer2 intrupt every 2ms
0000             12   ;    this allows for a 1 second delay, since the count1ms counter triggers a display 
0000             13   ;         update every 500 interupts.
0000             14   
0000             15   ; There is a couple of typos in MODLP51 in the definition of the timer 0/1 reload
0000             16   ; special function registers (SFRs), so:
0000             17   
0000             18   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000             19   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             20   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             21   TIMER2_RATE   EQU 500   ; 500Hz, for a timer tick of 2ms (timer overflows and triggers an interupt every 2ms -> goes to ISR)
0000             22   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             23   
0000             24   HOURS_BUTTON   equ P0.6
0000             25   SECONDS_BUTTON equ P0.0
0000             26   MINUTES_BUTTON equ P0.3
0000             27   AMPM_BUTTON    equ P4.5
0000             28   CLOCK_MODE     equ p2.1 ; controls between clock and alarm
0000             29   SOUND_OUT     equ P1.1
0000             30   
0000             31   ; Reset vector
0000             32   org 0x0000
0000 020217      33       ljmp main
0003             34   
0003             35   ; External interrupt 0 vector (not used in this code)
0003             36   org 0x0003
0003 32          37            reti
0004             38   
0004             39   ; Timer/Counter 0 overflow interrupt vector
000B             40   org 0x000B
000B 020118      41            ljmp Timer0_ISR
000E             42   
000E             43   ; External interrupt 1 vector (not used in this code)
0013             44   org 0x0013
0013 32          45            reti
0014             46   
0014             47   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             48   org 0x001B
001B 32          49            reti
001C             50   
001C             51   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             52   org 0x0023 
0023 32          53            reti
0024             54            
0024             55   ; Timer/Counter 2 overflow interrupt vector
002B             56   org 0x002B
002B 020181      57            ljmp Timer2_ISR
002E             58   
002E             59   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             60   dseg at 0x30
0030             61   Count2ms:     ds 2 ; Used to determine when half second has passed (2 bytes)
0032             62   seconds:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop (1 byte -> 8 bits)
0033             63   minutes:  ds 1 ; counter to keep track of minutes
0034             64   hours:    ds 1 ; counter to keep track of hours
0035             65   minutes_A:  ds 1 ; counter to keep track of minutes on alarm
0036             66   hours_A:    ds 1 ; counter to keep track of hours on alarm
0037             67   
0037             68   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0037             69   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             70   bseg
0000             71   one_second_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             72   AMPM_flag: dbit 1 ; flag for if we are in AM or PM time
0002             73   Alarm_Clock_flag: dbit 1 ;flag for modifying alarm or clock values (Alarm_Clock_flag = 1 means we can set an alarm)
0003             74   AMPM_flag_A: dbit 1
0004             75   AMPM_flag_A_set: dbit 1
0005             76   Alarm_mode: dbit 1
0006             77   Alarm_active: dbit 1
0007             78   
002E             79   cseg
002E             80   ; These 'equ' must match the hardware wiring
002E             81   LCD_RS equ P3.2
002E             82   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E             83   LCD_E  equ P3.3
002E             84   LCD_D4 equ P3.4
002E             85   LCD_D5 equ P3.5
002E             86   LCD_D6 equ P3.6
002E             87   LCD_D7 equ P3.7
002E             88   
                 90   	$LIST
00DA             92   
00DA             93   ;                     1234567890123456    <- This helps determine the location of the counter
00DA 54696D65    94   Time_Message:  db    'Time  xx:xx:xx ', 0
     20207878
     3A78783A
     78782000
00EA 416C6172    95   Alarm_Message: db    'Alarm xx:xx ',0
     6D207878
     3A787820
     00
00F7 6F6E2000    96   Alarm_On:      db    'on ', 0
00FB 6F666600    97   Alarm_Off:     db    'off', 0
00FF             98   
00FF             99   ;---------------------------------;
00FF            100   ; Routine to initialize the ISR   ;
00FF            101   ; for timer 0                     ;
00FF            102   ;---------------------------------;
00FF            103   Timer0_Init:
00FF E589       104            mov a, TMOD
0101 54F0       105            anl a, #0xf0 ; Clear the bits for timer 0
0103 4401       106            orl a, #0x01 ; Configure timer 0 as 16-timer
0105 F589       107            mov TMOD, a
0107 758CEA     108            mov TH0, #high(TIMER0_RELOAD)
010A 758AE8     109            mov TL0, #low(TIMER0_RELOAD)
010D            110            ; Set autoreload value
010D 75F4EA     111            mov RH0, #high(TIMER0_RELOAD)
0110 75F2E8     112            mov RL0, #low(TIMER0_RELOAD)
0113            113            ; Enable the timer and interrupts
0113 C2A9       114       clr ET0  ; disable timer 0 interrupt (we will do turn this on when the alarm triggers)
0115 D28C       115       setb TR0  ; Start timer 0
0117 22         116            ret
0118            117   
0118            118   ;---------------------------------;
0118            119   ; ISR for timer 0.  Set to execute;
0118            120   ; every 1/4096Hz to generate a    ;
0118            121   ; 2048 Hz square wave at pin P1.1 ;
0118            122   ;---------------------------------;
0118            123   Timer0_ISR:
0118            124            ;clr TF0  ; According to the data sheet this is done for us already.
0118 B291       125            cpl SOUND_OUT ; Connect speaker to P1.1 -> complements this pin on and off every 
011A 32         126            reti
011B            127   
011B            128   ;---------------------------------;
011B            129   ; Routine to initialize the ISR   ;
011B            130   ; for timer 2                     ;
011B            131   ;---------------------------------;
011B            132   Timer2_Init:
011B 75C800     133            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
011E 75CD53     134            mov TH2, #high(TIMER2_RELOAD)
0121 75CC34     135            mov TL2, #low(TIMER2_RELOAD)
0124            136            ; Set the reload value
0124 75CB53     137            mov RCAP2H, #high(TIMER2_RELOAD)
0127 75CA34     138            mov RCAP2L, #low(TIMER2_RELOAD)
012A            139            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
012A E4         140            clr a
012B F530       141            mov Count2ms+0, a
012D F531       142            mov Count2ms+1, a
012F            143            ; Enable the timer and interrupts
012F D2AD       144       setb ET2  ; Enable timer 2 interrupt
0131 D2CA       145       setb TR2  ; Enable timer 2
0133 22         146            ret
0134            147   change_AMPM_A: ; label to update AMPM flag for the alarm row
0134 C0E0       148            push acc
0136 740C       148            mov a, #12
0138 14         148            dec a
0139 1200BD     148            lcall ?Set_Cursor_2 ; Select column and row
013C D0E0       148            pop acc
013E 30040C     149            jnb AMPM_flag_A_set, write_AM_A ; if current flag is PM, update to AM
0141 C0E0       150            push acc
0143 7450       150            mov a, #'P'
0145 12007E     150            lcall ?WriteData
0148 D0E0       150            pop acc ; else, curruent flag was AM, update to PM
014A C204       151            clr AMPM_flag_A_set
014C 22         152            ret
014D            153            write_AM_A:
014D C0E0       154            push acc
014F 7441       154            mov a, #'A'
0151 12007E     154            lcall ?WriteData
0154 D0E0       154            pop acc
0156 D204       155                    setb AMPM_flag_A_set
0158 22         156                    ret
0159            157   change_AMPM:
0159 3003D8     158            jnb AMPM_flag_A, change_AMPM_A ; if we are in "ALARM" mode, we should change the AM/PM type for the second row (jump to AMPM_A label)
015C C0E0       159            push acc
015E 7410       159            mov a, #16
0160 14         159            dec a
0161 1200BF     159            lcall ?Set_Cursor_1 ; Select column and row
0164 D0E0       159            pop acc ; otherwise, change the AM/PM type for the first row
0166 30010C     160            jnb AMPM_flag, write_AM ; if current flag is PM, update to AM
0169 C0E0       161            push acc
016B 7450       161            mov a, #'P'
016D 12007E     161            lcall ?WriteData
0170 D0E0       161            pop acc ; else, current flag was AM, update to PM
0172 C201       162       clr AMPM_flag
0174 22         163       ret
0175            164            write_AM:
0175 C0E0       165            push acc
0177 7441       165            mov a, #'A'
0179 12007E     165            lcall ?WriteData
017C D0E0       165            pop acc
017E D201       166            setb AMPM_flag
0180 22         167            ret
0181            168   ;---------------------------------;
0181            169   ; ISR for timer 2                 ;
0181            170   ;---------------------------------;
0181            171   ; In this subroutine, we can check our "alarm flag (to be created)" if our alarm is off or on
0181            172   ; If alarm is on, we need to somehow compare the current time with the alarm time, and trigger a 
0181            173   ; call to another subroutine that will activate the alarm and use the speaker 
0181            174   ; until we push the button that turns the alarm off. 
0181            175   Timer2_ISR: ;triggers when timer has overflowed (occurs after 2ms)
0181 C2CF       176            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0183 B290       177            cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0185            178            
0185            179            ; The two registers used in the ISR must be saved in the stack
0185 C0E0       180            push acc ; push accumulator to stack
0187 C0D0       181            push psw ; push status flag to stack
0189            182            
0189            183            ; Increment the 16-bit one mili second counter
0189 0530       184            inc Count2ms+0    ; Increment the low 8-bits first
018B E530       185            mov a, Count2ms+0 ; If the low 8-bits overflow, then increment high 8-bits
018D 7002       186            jnz Inc_Done
018F 0531       187            inc Count2ms+1
0191            188   
0191            189   Inc_Done:
0191            190            ; Check if half second has passed
0191 E530       191            mov a, Count2ms+0
0193 B4F430     192            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0196 E531       193            mov a, Count2ms+1
0198 B4012B     194            cjne a, #high(500), Timer2_ISR_done
019B            195            
019B            196            ; 500 milliseconds have passed.  Set a flag so the main program knows
019B D200       197            setb one_second_flag ; Let the main program know one second had passed
019D B28C       198            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
019F            199            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
019F E4         200            clr a
01A0            201            ;reset the 2ms counter
01A0 F530       202            mov Count2ms+0, a 
01A2 F531       203            mov Count2ms+1, a
01A4            204            ; Increment the seconds counter by 1
01A4 1201D7     205            lcall Update_Seconds
01A7 B4601C     206            cjne a, #0x60, Timer2_ISR_done ; check if seconds has reached 60 (if not 60, jump to Timer2_ISR_done)
01AA            207            
01AA            208   Update_Times: ;update all times subroutine (will trigger if we have reached a 60 seconds mark
01AA E4         209            clr a
01AB F532       210            mov seconds, a ;reset seconds to 0
01AD 1201DF     211            lcall Update_Minutes ; update minutes call
01B0 E533       212            mov a, minutes
01B2 B46011     213            cjne a, #0x60, Timer2_ISR_done ; check if minutes has reached 60 (if not 60, skip to Timer2_ISR_done)
01B5 E4         214            clr a
01B6 F533       215            mov minutes, a ; reset minutes to 0
01B8 1201FB     216            lcall Update_Hours ; update hours call
01BB E534       217            mov a, hours
01BD B41306     218            cjne a, #0x13, Timer2_ISR_done ; check if hours was at 12:00 when we reached 60 minutes(if not, goto Timer2_ISR_done)
01C0 753401     219            mov hours, #0x01 ; reset hours back to 1:00 if it was at 12:00 when we reached 60 minutes
01C3 120159     220            lcall change_AMPM ; if hours has gone over 12:00, we need to change the AMPM flag
01C6            221            
01C6            222   Timer2_ISR_done:
01C6            223            ; after all our relevant times have updated, we should compare the current time with the alarm time if the alarm is active
01C6 300509     224            jnb Alarm_mode, real_done ; if Alarm_mode is off, we skip to Timer2_ISR_done
01C9 E533       225            mov a, minutes
01CB B53504     226            cjne a, minutes_A, real_done ; if minutes_clock != minutes_A skip to Timer2_ISR_done, else check hours next
01CE            227            ;mov a, hours
01CE            228            ;cjne a, #hours_A, Timer2_ISR_done ; if hours_clock != hours_A skips to TImer2_ISR_done, else check if AM/PM matches
01CE            229            ;mov a, AMPM_flag
01CE            230            ;cjne a, #AMPM_flag_A_set, Timer2_ISR_done ; if AM/PM on the clock != AM/PM on the alarm, times are not equal so skip to done
01CE            231            ; if we made it here, the clock time equals the alarm time, so that means we need to sound the alarm
01CE D206       232            setb Alarm_active ; turn on the alarm active flag
01D0 D2A9       233            setb ET0 ; enable Timer_0 interrupt -> this will cause our alarm to go off
01D2            234            
01D2            235            real_done:
01D2 D0D0       236                    pop psw
01D4 D0E0       237                    pop acc
01D6 32         238                    reti ;return from the interupt
01D7            239            
01D7            240   Update_Seconds:
01D7 E532       241            mov a, seconds
01D9 2401       242            add a, #0x01
01DB D4         243            da a ;value in a -> BCD
01DC F532       244            mov seconds, a ; seconds = BCD value
01DE 22         245            ret
01DF            246            
01DF            247   Update_Minutes:  ; updates either clock or alarm minute value
01DF 300211     248            jnb Alarm_Clock_flag, Minutes_Clock ; if not in alarm mode, update the clock time values
01E2 E535       249            mov a, minutes_A ; else, update the alarm values
01E4 2401       250            add a, #0x01
01E6 D4         251            da a ;value in a -> BCD
01E7 F535       252            mov minutes_A, a ; seconds = BCD value
01E9 B46006     253            cjne a, #0x60, minute_A_done ; check if our alarm_minutes value has gone over 60 (if not, skip to minute_A_done)
01EC 753500     254            mov minutes_A, #0x00 ; else, reset minute_A, and update the hours
01EF 1201FB     255            lcall Update_Hours
01F2            256            minute_A_done:
01F2 22         257                    ret
01F3            258            Minutes_Clock:
01F3 E533       259                    mov a, minutes ; check minutes
01F5 2401       260                    add a, #0x01 ; increment minutes by 1
01F7 D4         261                    da a 
01F8 F533       262                    mov minutes, a  
01FA 22         263                    ret
01FB            264   Update_Hours: ; updates either clock or alarm hour value
01FB 300211     265            jnb Alarm_Clock_flag, Hours_Clock ; if not in alarm mode, update the clock hour values
01FE E536       266            mov a, hours_A
0200 2401       267            add a, #0x01
0202 D4         268            da a ;value in a -> BCD
0203 F536       269            mov hours_A, a ; seconds = BCD value
0205 B41306     270            cjne a, #0x13, hours_A_done
0208 753601     271            mov hours_A, #0x01
020B 120159     272            lcall change_AMPM ; if we have gone over 12 hours, we need to change AM/PM
020E            273            
020E            274            hours_A_done:
020E 22         275                    ret
020F            276            Hours_Clock:
020F E534       277                    mov a, hours
0211 2401       278                    add a, #0x01 ; increment hours by 1
0213 D4         279                    da a
0214 F534       280                    mov hours, a
0216 22         281                    ret
0217            282            
0217            283   ;---------------------------------;
0217            284   ; Main program. Includes hardware ;
0217            285   ; initialization and 'forever'    ;
0217            286   ; loop.                           ;
0217            287   ;---------------------------------;
0217            288   main:
0217            289            ; Initialization
0217 75817F     290       mov SP, #0x7F
021A 1200FF     291       lcall Timer0_Init
021D 12011B     292       lcall Timer2_Init
0220            293       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
0220 75E600     294       mov P0M0, #0
0223 75E700     295       mov P0M1, #0
0226 D2C5       296       setb p4.5
0228 D2AF       297       setb EA   ; Enable Global interrupts
022A 120088     298       lcall LCD_4BIT
022D            299       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
022D C0E0       300            push acc
022F 7401       300            mov a, #1
0231 14         300            dec a
0232 1200BF     300            lcall ?Set_Cursor_1 ; Select column and row
0235 D0E0       300            pop acc
0237 C083       301            push dph
0239 C082       301            push dpl
023B C0E0       301            push acc
023D 9000DA     301            mov dptr, #Time_Message
0240 1200B2     301            lcall ?Send_Constant_String
0243 D0E0       301            pop acc
0245 D082       301            pop dpl
0247 D083       301            pop dph
0249 C0E0       302            push acc
024B 7401       302            mov a, #1
024D 14         302            dec a
024E 1200BD     302            lcall ?Set_Cursor_2 ; Select column and row
0251 D0E0       302            pop acc
0253 C083       303            push dph
0255 C082       303            push dpl
0257 C0E0       303            push acc
0259 9000EA     303            mov dptr, #Alarm_Message
025C 1200B2     303            lcall ?Send_Constant_String
025F D0E0       303            pop acc
0261 D082       303            pop dpl
0263 D083       303            pop dph
0265 C0E0       304            push acc
0267 7410       304            mov a, #16
0269 14         304            dec a
026A 1200BF     304            lcall ?Set_Cursor_1 ; Select column and row
026D D0E0       304            pop acc
026F C0E0       305            push acc
0271 7441       305            mov a, #'A'
0273 12007E     305            lcall ?WriteData
0276 D0E0       305            pop acc
0278 C0E0       306            push acc
027A 740C       306            mov a, #12
027C 14         306            dec a
027D 1200BD     306            lcall ?Set_Cursor_2 ; Select column and row
0280 D0E0       306            pop acc
0282 C0E0       307            push acc
0284 7441       307            mov a, #'A'
0286 12007E     307            lcall ?WriteData
0289 D0E0       307            pop acc
028B C0E0       308            push acc
028D 740E       308            mov a, #14
028F 14         308            dec a
0290 1200BD     308            lcall ?Set_Cursor_2 ; Select column and row
0293 D0E0       308            pop acc
0295 C083       309            push dph
0297 C082       309            push dpl
0299 C0E0       309            push acc
029B 9000FB     309            mov dptr, #Alarm_off
029E 1200B2     309            lcall ?Send_Constant_String
02A1 D0E0       309            pop acc
02A3 D082       309            pop dpl
02A5 D083       309            pop dph ; initially display that the alarm is turned off
02A7 D200       310       setb one_second_flag
02A9 D201       311       setb AMPM_flag
02AB D203       312       setb AMPM_flag_A
02AD D204       313       setb AMPM_flag_A_set
02AF C202       314       clr Alarm_Clock_flag ; alarm clock flag initially set to zero
02B1 C205       315       clr Alarm_mode ; alarm should be automatically set to off
02B3 C206       316       clr Alarm_active ; make sure alarm is not active
02B5 753200     317            mov seconds, #0x00 ;initialize seconds to zero
02B8 753300     318            mov minutes, #0x00 ;initialize minutes to zero
02BB 753400     319            mov hours, #0x00 ;initialize hours to zero
02BE 753500     320            mov minutes_A, #0x00
02C1 753600     321            mov hours_A, #0x00
02C4            322   
02C4            323   Alarm_OnOff: ; defaults to alarm OFF after passing through the main initialization loop
02C4 30024C     324            jnb Alarm_Clock_flag, loop ; if we enter here after main, makes sure alarm is kept off and skip to loop
02C7 300523     325            jnb Alarm_mode, turn_A_on ; if Alarm_mode is zero (off) we want to turn it on
02CA B205       326                    cpl Alarm_mode ; else, we turn off Alarm_mode
02CC C0E0       327            push acc
02CE 740E       327            mov a, #14
02D0 14         327            dec a
02D1 1200BD     327            lcall ?Set_Cursor_2 ; Select column and row
02D4 D0E0       327            pop acc
02D6 C083       328            push dph
02D8 C082       328            push dpl
02DA C0E0       328            push acc
02DC 9000FB     328            mov dptr, #Alarm_Off
02DF 1200B2     328            lcall ?Send_Constant_String
02E2 D0E0       328            pop acc
02E4 D082       328            pop dpl
02E6 D083       328            pop dph ; write 'off' in the alarm field
02E8 200622     329                    jb Alarm_active, turn_off_alarm ; if the alarm is actively sounding, we want to turn it off once we turn off Alarm_mode
02EB 8058       330                    sjmp check_hours_push ; jump back to the next stage in our button daisy chain
02ED            331            turn_A_on:
02ED B205       332                    cpl Alarm_mode ; set Alarm_mode to 1
02EF C0E0       333            push acc
02F1 740E       333            mov a, #14
02F3 14         333            dec a
02F4 1200BD     333            lcall ?Set_Cursor_2 ; Select column and row
02F7 D0E0       333            pop acc
02F9 C083       334            push dph
02FB C082       334            push dpl
02FD C0E0       334            push acc
02FF 9000F7     334            mov dptr, #Alarm_On
0302 1200B2     334            lcall ?Send_Constant_String
0305 D0E0       334            pop acc
0307 D082       334            pop dpl
0309 D083       334            pop dph ; write 'on' in the alarm field
030B 8038       335                    sjmp check_hours_push ; jump back to the next stage in our button daisy chain
030D            336   turn_off_alarm: ; sub-routine that turns off the active alarm by complementing the ET0 (timer 0 interrupt)
030D C2A9       337            clr ET0 ; turn off timer_0 interrupt, which will stop the noise
030F C206       338            clr Alarm_active ; turn off the active alarm flag
0311 8032       339            sjmp check_hours_push ; resume button checking
0313            340   loop: ; After initialization the program stays in this 'forever' loop
0313 20802F     341            jb SECONDS_BUTTON, check_hours_push  ; if the 'BOOT' button is not pressed goto loop_a
0316 C002       342            push AR2
0318 7A32       342            mov R2, #50
031A 120039     342            lcall ?Wait_Milli_Seconds
031D D002       342            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
031F 208023     343            jb SECONDS_BUTTON, check_hours_push  ; if the 'BOOT' button is not pressed, goto loop_a 
0322 3080FD     344            jnb SECONDS_BUTTON, $     
0325 20029C     345            jb Alarm_Clock_flag, Alarm_OnOff ; if we are in alarm mode and the seconds button is pressed, toggle alarm on/off
0328            346   second_push: ; change second value from p0.0 pushbutton
0328 1201D7     347            lcall Update_Seconds ; increments seconds by 1
032B B4606A     348            cjne a, #0x60, loop_b ; if seconds != 60, display all time values
032E 753200     349            mov seconds, #0x00
0331 1201DF     350            lcall Update_Minutes ; else, reset seconds to 0 and update minutes
0334 B46061     351            cjne a, #0x60, loop_b ; if minutes != 60, display all time values
0337 1201FB     352            lcall Update_Hours ; else, update the hours and reset minutes to 0
033A B4135B     353            cjne a, #0x13, loop_b ; check if hours was at 12:00 when we reached 60 minutes(if not, goto Timer2_ISR_done)
033D 753401     354            mov hours, #0x01 ; reset hours back to 1:00 if it was at 12:00 when we reached 60 minutes
0340 120159     355            lcall change_AMPM
0343 8053       356            sjmp loop_b             ; Display the new value
0345            357   check_hours_push: ; change hour value from p0.6 pushbutton
0345 208625     358            jb HOURS_BUTTON, check_minutes_push  ; if the 'BOOT' button is not pressed goto loop_a
0348 C002       359            push AR2
034A 7A32       359            mov R2, #50
034C 120039     359            lcall ?Wait_Milli_Seconds
034F D002       359            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0351 208619     360            jb HOURS_BUTTON, check_minutes_push  ; if the 'BOOT' button is not pressed, goto loop_a 
0354 3086FD     361            jnb HOURS_BUTTON, $        
0357            362   hour_push:
0357 1201FB     363            lcall Update_Hours
035A E534       364            mov a, hours
035C B41339     365            cjne a, #0x13, loop_b
035F 753401     366            mov hours, #0x01
0362 120159     367            lcall change_AMPM
0365 8031       368            sjmp loop_b
0367            369   loop_a: ; maximum distance from loop label for jnb to work
0367 3000A9     370            jnb one_second_flag, loop
036A 020398     371            ljmp loop_b
036D            372   check_minutes_push: ; change minute values from p0.3 pushbutton
036D 208330     373            jb MINUTES_BUTTON, check_AMPM_push  ; if the 'BOOT' button is not pressed goto loop_a
0370 C002       374            push AR2
0372 7A32       374            mov R2, #50
0374 120039     374            lcall ?Wait_Milli_Seconds
0377 D002       374            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0379 208324     375            jb MINUTES_BUTTON, check_AMPM_push  ; if the 'BOOT' button is not pressed, goto loop_a 
037C 3083FD     376            jnb MINUTES_BUTTON, $      
037F            377   minute_push:
037F 1201DF     378            lcall Update_Minutes
0382 E533       379            mov a, minutes
0384 B46011     380            cjne a, #0x60, loop_b
0387 753300     381            mov minutes, #0x00
038A 1201FB     382            lcall Update_Hours
038D B41308     383            cjne a, #0x13, loop_b
0390 753401     384            mov hours, #0x01
0393 120159     385            lcall change_AMPM
0396 8000       386            sjmp loop_b
0398            387            
0398            388   ; we should control whether or not we change the clock vs. alarm digits in this loop
0398            389   ; probably need to have an alarm flag (on/off) that will control which line we edit (clock/alarm)
0398            390   ; we also probably need seperate counters for minutes and hours
0398            391   loop_b: ;if one_second flag is high or we have reset the clock values, we enter this loop
0398 C200       392       clr one_second_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
039A 1203CF     393       lcall write_times ; prints all times to the display
039D 020313     394       ljmp loop
03A0            395      
03A0            396   check_AMPM_push: ; change between AM/PM using p4.5 pushbutton
03A0 20C514     397            jb AMPM_BUTTON, check_mode_push  ; if the 'BOOT' button is not pressed goto loop_a
03A3 C002       398            push AR2
03A5 7A32       398            mov R2, #50
03A7 120039     398            lcall ?Wait_Milli_Seconds
03AA D002       398            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03AC 20C508     399            jb AMPM_BUTTON, check_mode_push  ; if the 'BOOT' button is not pressed, goto loop_a 
03AF 30C5FD     400            jnb AMPM_BUTTON, $         ; Wait for button release.  The '$' means: jump to same instruction
03B2            401   AMPM_push:
03B2 120159     402            lcall change_AMPM
03B5 80E1       403            sjmp loop_b
03B7            404   check_mode_push: ; change between clock/alarm value editing mode using p2.1 pushbutton
03B7 20A1AD     405            jb CLOCK_MODE, loop_a  ; if the 'BOOT' button is not pressed goto loop_a
03BA C002       406            push AR2
03BC 7A32       406            mov R2, #50
03BE 120039     406            lcall ?Wait_Milli_Seconds
03C1 D002       406            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03C3 20A1A1     407            jb CLOCK_MODE, loop_a  ; if the 'BOOT' button is not pressed, goto loop_a 
03C6 30A1FD     408            jnb CLOCK_MODE, $          ; Wait for button release.  The '$' means: jump to same instruction
03C9            409   mode_push:
03C9 B202       410            cpl Alarm_Clock_flag ; triggers if we switch to "alarm" or "clock" editing mode
03CB B203       411            cpl AMPM_flag_A ; flag to allow us to control the AM and PM setting in the ALARM row
03CD            412            ;cpl ET2  ; Disable/Enable timer 2 interrupt
03CD 80C9       413            sjmp loop_b
03CF            414   write_times: ; label to write all relevant time values to the LCD
03CF C0E0       415            push acc
03D1 740D       415            mov a, #13
03D3 14         415            dec a
03D4 1200BF     415            lcall ?Set_Cursor_1 ; Select column and row
03D7 D0E0       415            pop acc     ; the place in the LCD where we want the BCD counter value
03D9 C000       416            push ar0
03DB A832       416            mov r0, seconds
03DD 1200C4     416            lcall ?Display_BCD
03E0 D000       416            pop ar0 ; This macro is also in 'LCD_4bit.inc'
03E2 C0E0       417            push acc
03E4 740A       417            mov a, #10
03E6 14         417            dec a
03E7 1200BF     417            lcall ?Set_Cursor_1 ; Select column and row
03EA D0E0       417            pop acc
03EC C000       418            push ar0
03EE A833       418            mov r0, minutes
03F0 1200C4     418            lcall ?Display_BCD
03F3 D000       418            pop ar0
03F5 C0E0       419            push acc
03F7 7407       419            mov a, #7
03F9 14         419            dec a
03FA 1200BF     419            lcall ?Set_Cursor_1 ; Select column and row
03FD D0E0       419            pop acc
03FF C000       420            push ar0
0401 A834       420            mov r0, hours
0403 1200C4     420            lcall ?Display_BCD
0406 D000       420            pop ar0
0408 C0E0       421            push acc
040A 7407       421            mov a, #7
040C 14         421            dec a
040D 1200BD     421            lcall ?Set_Cursor_2 ; Select column and row
0410 D0E0       421            pop acc
0412 C000       422            push ar0
0414 A836       422            mov r0, hours_A
0416 1200C4     422            lcall ?Display_BCD
0419 D000       422            pop ar0
041B C0E0       423            push acc
041D 740A       423            mov a, #10
041F 14         423            dec a
0420 1200BD     423            lcall ?Set_Cursor_2 ; Select column and row
0423 D0E0       423            pop acc
0425 C000       424            push ar0
0427 A835       424            mov r0, minutes_A
0429 1200C4     424            lcall ?Display_BCD
042C D000       424            pop ar0
042E 22         425            ret
042F            426       
042F            427   END

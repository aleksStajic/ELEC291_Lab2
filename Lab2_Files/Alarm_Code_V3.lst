0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P1.1 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'BOOT' pushbutton connected to P4.5 is pressed.
                  7   $LIST
0000              9   
0000             10   ; My adaptations
0000             11   ; 1. Changed the TIMER2_Rate to 500Hz, so that we trigger a timer2 intrupt every 2ms
0000             12   ;    this allows for a 1 second delay, since the count1ms counter triggers a display 
0000             13   ;         update every 500 interupts.
0000             14   
0000             15   ; There is a couple of typos in MODLP51 in the definition of the timer 0/1 reload
0000             16   ; special function registers (SFRs), so:
0000             17   
0000             18   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
0000             19   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             20   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0000             21   TIMER2_RATE   EQU 500   ; 500Hz, for a timer tick of 2ms (timer overflows and triggers an interupt every 2ms -> goes to ISR)
0000             22   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0000             23   
0000             24   HOURS_BUTTON   equ P0.6
0000             25   SECONDS_BUTTON equ P0.0
0000             26   MINUTES_BUTTON equ P0.3
0000             27   AMPM_BUTTON    equ P4.5
0000             28   CLOCK_MODE     equ p2.1 ; controls between clock and alarm
0000             29   SOUND_OUT     equ P1.1
0000             30   
0000             31   ; Reset vector
0000             32   org 0x0000
0000 02023A      33       ljmp main
0003             34   
0003             35   ; External interrupt 0 vector (not used in this code)
0003             36   org 0x0003
0003 32          37            reti
0004             38   
0004             39   ; Timer/Counter 0 overflow interrupt vector
000B             40   org 0x000B
000B 020118      41            ljmp Timer0_ISR
000E             42   
000E             43   ; External interrupt 1 vector (not used in this code)
0013             44   org 0x0013
0013 32          45            reti
0014             46   
0014             47   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             48   org 0x001B
001B 32          49            reti
001C             50   
001C             51   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             52   org 0x0023 
0023 32          53            reti
0024             54            
0024             55   ; Timer/Counter 2 overflow interrupt vector
002B             56   org 0x002B
002B 020181      57            ljmp Timer2_ISR
002E             58   
002E             59   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             60   dseg at 0x30
0030             61   Count2ms:     ds 2 ; Used to determine when half second has passed (2 bytes)
0032             62   seconds:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop (1 byte -> 8 bits)
0033             63   minutes:  ds 1 ; counter to keep track of minutes
0034             64   hours:    ds 1 ; counter to keep track of hours
0035             65   minutes_A:  ds 1 ; counter to keep track of minutes on alarm
0036             66   hours_A:    ds 1 ; counter to keep track of hours on alarm
0037             67   
0037             68   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0037             69   ; instructions with these variables.  This is how you define a 1-bit variable:
0000             70   bseg
0000             71   one_second_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0001             72   AMPM_flag: dbit 1 ; flag for if we are in AM or PM time
0002             73   Alarm_Clock_flag: dbit 1 ;flag for modifying alarm or clock values (Alarm_Clock_flag = 1 means we can set an alarm)
0003             74   AMPM_flag_A: dbit 1
0004             75   AMPM_flag_A_set: dbit 1
0005             76   Alarm_mode: dbit 1
0006             77   Alarm_active: dbit 1
0007             78   
002E             79   cseg
002E             80   ; These 'equ' must match the hardware wiring
002E             81   LCD_RS equ P3.2
002E             82   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
002E             83   LCD_E  equ P3.3
002E             84   LCD_D4 equ P3.4
002E             85   LCD_D5 equ P3.5
002E             86   LCD_D6 equ P3.6
002E             87   LCD_D7 equ P3.7
002E             88   
                 90   	$LIST
00DA             92   
00DA             93   ;                     1234567890123456    <- This helps determine the location of the counter
00DA 54696D65    94   Time_Message:  db    'Time  xx:xx:xx ', 0
     20207878
     3A78783A
     78782000
00EA 416C6172    95   Alarm_Message: db    'Alarm xx:xx ',0
     6D207878
     3A787820
     00
00F7 6F6E2000    96   Alarm_On:      db    'on ', 0
00FB 6F666600    97   Alarm_Off:     db    'off', 0
00FF             98   
00FF             99   ;---------------------------------;
00FF            100   ; Routine to initialize the ISR   ;
00FF            101   ; for timer 0                     ;
00FF            102   ;---------------------------------;
00FF            103   Timer0_Init:
00FF E589       104            mov a, TMOD
0101 54F0       105            anl a, #0xf0 ; Clear the bits for timer 0
0103 4401       106            orl a, #0x01 ; Configure timer 0 as 16-timer
0105 F589       107            mov TMOD, a
0107 758CEA     108            mov TH0, #high(TIMER0_RELOAD)
010A 758AE8     109            mov TL0, #low(TIMER0_RELOAD)
010D            110            ; Set autoreload value
010D 75F4EA     111            mov RH0, #high(TIMER0_RELOAD)
0110 75F2E8     112            mov RL0, #low(TIMER0_RELOAD)
0113            113            ; Enable the timer and interrupts
0113 C2A9       114       clr ET0  ; disable timer 0 interrupt (we will do turn this on when the alarm triggers)
0115 D28C       115       setb TR0  ; Start timer 0
0117 22         116            ret
0118            117   
0118            118   ;---------------------------------;
0118            119   ; ISR for timer 0.  Set to execute;
0118            120   ; every 1/4096Hz to generate a    ;
0118            121   ; 2048 Hz square wave at pin P1.1 ;
0118            122   ;---------------------------------;
0118            123   Timer0_ISR:
0118            124            ;clr TF0  ; According to the data sheet this is done for us already.
0118 B291       125            cpl SOUND_OUT ; Connect speaker to P1.1 -> complements this pin on and off every 
011A 32         126            reti
011B            127   
011B            128   ;---------------------------------;
011B            129   ; Routine to initialize the ISR   ;
011B            130   ; for timer 2                     ;
011B            131   ;---------------------------------;
011B            132   Timer2_Init:
011B 75C800     133            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
011E 75CD53     134            mov TH2, #high(TIMER2_RELOAD)
0121 75CC34     135            mov TL2, #low(TIMER2_RELOAD)
0124            136            ; Set the reload value
0124 75CB53     137            mov RCAP2H, #high(TIMER2_RELOAD)
0127 75CA34     138            mov RCAP2L, #low(TIMER2_RELOAD)
012A            139            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
012A E4         140            clr a
012B F530       141            mov Count2ms+0, a
012D F531       142            mov Count2ms+1, a
012F            143            ; Enable the timer and interrupts
012F D2AD       144       setb ET2  ; Enable timer 2 interrupt
0131 D2CA       145       setb TR2  ; Enable timer 2
0133 22         146            ret
0134            147   change_AMPM_A: ; label to update AMPM flag for the alarm row
0134 C0E0       148            push acc
0136 740C       148            mov a, #12
0138 14         148            dec a
0139 1200BD     148            lcall ?Set_Cursor_2 ; Select column and row
013C D0E0       148            pop acc
013E 30040C     149            jnb AMPM_flag_A_set, write_AM_A ; if current flag is PM, update to AM
0141 C0E0       150            push acc
0143 7450       150            mov a, #'P'
0145 12007E     150            lcall ?WriteData
0148 D0E0       150            pop acc ; else, curruent flag was AM, update to PM
014A C204       151            clr AMPM_flag_A_set
014C 22         152            ret
014D            153            write_AM_A:
014D C0E0       154            push acc
014F 7441       154            mov a, #'A'
0151 12007E     154            lcall ?WriteData
0154 D0E0       154            pop acc
0156 D204       155                    setb AMPM_flag_A_set
0158 22         156                    ret
0159            157   change_AMPM:
0159 3003D8     158            jnb AMPM_flag_A, change_AMPM_A ; if we are in "ALARM" mode, we should change the AM/PM type for the second row (jump to AMPM_A label)
015C C0E0       159            push acc
015E 7410       159            mov a, #16
0160 14         159            dec a
0161 1200BF     159            lcall ?Set_Cursor_1 ; Select column and row
0164 D0E0       159            pop acc ; otherwise, change the AM/PM type for the first row
0166 30010C     160            jnb AMPM_flag, write_AM ; if current flag is PM, update to AM
0169 C0E0       161            push acc
016B 7450       161            mov a, #'P'
016D 12007E     161            lcall ?WriteData
0170 D0E0       161            pop acc ; else, current flag was AM, update to PM
0172 C201       162       clr AMPM_flag
0174 22         163       ret
0175            164            write_AM:
0175 C0E0       165            push acc
0177 7441       165            mov a, #'A'
0179 12007E     165            lcall ?WriteData
017C D0E0       165            pop acc
017E D201       166            setb AMPM_flag
0180 22         167            ret
0181            168   ;---------------------------------;
0181            169   ; ISR for timer 2                 ;
0181            170   ;---------------------------------;
0181            171   ; In this subroutine, we can check our "alarm flag (to be created)" if our alarm is off or on
0181            172   ; If alarm is on, we need to somehow compare the current time with the alarm time, and trigger a 
0181            173   ; call to another subroutine that will activate the alarm and use the speaker 
0181            174   ; until we push the button that turns the alarm off. 
0181            175   Timer2_ISR: ;triggers when timer has overflowed (occurs after 2ms)
0181 C2CF       176            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0183 B290       177            cpl P1.0 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
0185            178            
0185            179            ; The two registers used in the ISR must be saved in the stack
0185 C0E0       180            push acc ; push accumulator to stack
0187 C0D0       181            push psw ; push status flag to stack
0189            182            
0189            183            ; Increment the 16-bit one mili second counter
0189 0530       184            inc Count2ms+0    ; Increment the low 8-bits first
018B E530       185            mov a, Count2ms+0 ; If the low 8-bits overflow, then increment high 8-bits
018D 7002       186            jnz Inc_Done
018F 0531       187            inc Count2ms+1
0191            188   
0191            189   Inc_Done:
0191            190            ; Check if half second has passed
0191 E530       191            mov a, Count2ms+0
0193 B4F42D     192            cjne a, #low(500), Timer2_ISR_done ; Warning: this instruction changes the carry flag!
0196 E531       193            mov a, Count2ms+1
0198 B40128     194            cjne a, #high(500), Timer2_ISR_done
019B            195            
019B            196            ; 500 milliseconds have passed.  Set a flag so the main program knows
019B D200       197            setb one_second_flag ; Let the main program know one second had passed
019D B28C       198            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
019F            199            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
019F E4         200            clr a
01A0            201            ;reset the 2ms counter
01A0 F530       202            mov Count2ms+0, a 
01A2 F531       203            mov Count2ms+1, a
01A4            204            ; Increment the seconds counter by 1
01A4 1201F1     205            lcall Update_Seconds
01A7 B46019     206            cjne a, #0x60, Timer2_ISR_done ; check if seconds has reached 60 (if not 60, jump to Timer2_ISR_done)
01AA            207            
01AA            208   Update_Times: ;update all times subroutine (will trigger if we have reached a 60 seconds mark
01AA E4         209            clr a
01AB F532       210            mov seconds, a ;reset seconds to 0
01AD 1201F9     211            lcall Update_Minutes ; update minutes call
01B0 E533       212            mov a, minutes
01B2 B4600E     213            cjne a, #0x60, Timer2_ISR_done ; check if minutes has reached 60 (if not 60, skip to Timer2_ISR_done)
01B5 E4         214            clr a
01B6 F533       215            mov minutes, a ; reset minutes to 0
01B8 120215     216            lcall Update_Hours ; update hours call
01BB E534       217            mov a, hours
01BD B41303     218            cjne a, #0x13, Timer2_ISR_done ; check if hours was at 12:00 when we reached 60 minutes(if not, goto Timer2_ISR_done)
01C0 753401     219            mov hours, #0x01 ; reset hours back to 1:00 if it was at 12:00 when we reached 60 minutes
01C3            220            
01C3            221   Timer2_ISR_done:
01C3            222            ; after all our relevant times have updated, we should compare the current time with the alarm time if the alarm is active
01C3 300526     223            jnb Alarm_mode, real_done ; if Alarm_mode is off, we skip to Timer2_ISR_done
01C6 E533       224            mov a, minutes
01C8 B53521     225            cjne a, minutes_A, real_done ; if minutes_clock != minutes_A skip to Timer2_ISR_done, else check hours next
01CB E534       226            mov a, hours
01CD B5361C     227            cjne a, hours_A, real_done ; if hours_clock != hours_A skips to TImer2_ISR_done, else check if AM/PM matches
01D0 200109     228            jb AMPM_flag, check1 ; if AMPM_flag = 1, check if AMPM_flag_A_set also is 1 (that means bboth alarm and clock are in AM)
01D3 30010F     229            jnb AMPM_flag, check2 ; if AMPM_flag = 0, check if AMPM_flag_A_set also is 0 (that means bboth alarm and clock are in PM)
01D6            230            ; if AM/PM on the clock != AM/PM on the alarm, times are not equal so skip to done
01D6            231            ; if we made it here, the clock time equals the alarm time, so that means we need to sound the alarm
01D6 D206       232            setb Alarm_active ; turn on the alarm active flag
01D8 D2A9       233            setb ET0 ; enable Timer_0 interrupt -> this will cause our alarm to go off
01DA 8010       234            sjmp real_done
01DC            235            check1:
01DC 30040D     236                    jnb AMPM_flag_A_set, real_done ; if AMPM_flag_A_set = 0, that means clock is in AM, alarm is in PM, so goto real_done
01DF D206       237                    setb Alarm_active ; else, trigger alarm
01E1 D2A9       238                    setb ET0
01E3 8007       239                    sjmp real_done
01E5            240            check2: 
01E5 200404     241                    jb AMPM_flag_A_set, real_done ;if AMPM_flag_A_set = 1, that means clock is in PM, alarm is in AM, so goto real_done
01E8 D206       242                    setb Alarm_active ; else, trigger alarm
01EA D2A9       243                    setb ET0
01EC            244            real_done:
01EC D0D0       245                    pop psw
01EE D0E0       246                    pop acc
01F0 32         247                    reti ;return from the interupt
01F1            248            
01F1            249   Update_Seconds:
01F1 E532       250            mov a, seconds
01F3 2401       251            add a, #0x01
01F5 D4         252            da a ;value in a -> BCD
01F6 F532       253            mov seconds, a ; seconds = BCD value
01F8 22         254            ret
01F9            255            
01F9            256   Update_Minutes:  ; updates either clock or alarm minute value
01F9 300211     257            jnb Alarm_Clock_flag, Minutes_Clock ; if not in alarm mode, update the clock time values
01FC E535       258            mov a, minutes_A ; else, update the alarm values
01FE 2401       259            add a, #0x01
0200 D4         260            da a ;value in a -> BCD
0201 F535       261            mov minutes_A, a ; seconds = BCD value
0203 B46006     262            cjne a, #0x60, minute_A_done ; check if our alarm_minutes value has gone over 60 (if not, skip to minute_A_done)
0206 753500     263            mov minutes_A, #0x00 ; else, reset minute_A, and update the hours
0209 120215     264            lcall Update_Hours
020C            265            minute_A_done:
020C 22         266                    ret
020D            267            Minutes_Clock:
020D E533       268                    mov a, minutes ; check minutes
020F 2401       269                    add a, #0x01 ; increment minutes by 1
0211 D4         270                    da a 
0212 F533       271                    mov minutes, a  
0214 22         272                    ret
0215            273   Update_Hours: ; updates either clock or alarm hour value
0215 300214     274            jnb Alarm_Clock_flag, Hours_Clock ; if not in alarm mode, update the clock hour values
0218 E536       275            mov a, hours_A
021A 2401       276            add a, #0x01 ; increment alarm hour value
021C D4         277            da a ;value in a -> BCD
021D F536       278            mov hours_A, a ; seconds = BCD value
021F B41203     279            cjne a, #0x12, hours_A_done0
0222 120159     280            lcall change_AMPM
0225            281            hours_A_done0:
0225 B41303     282            cjne a, #0x13, hours_A_done
0228 753601     283            mov hours_A, #0x01
022B            284            
022B            285            hours_A_done:
022B 22         286                    ret
022C            287            Hours_Clock:
022C E534       288                    mov a, hours
022E 2401       289                    add a, #0x01 ; increment hours by 1
0230 D4         290                    da a
0231 F534       291                    mov hours, a
0233 B41203     292                    cjne a, #0x12, done_hours ; if hours is not equal to 12, we can go to done
0236            293                    ; else, we should change AMPM
0236 120159     294                    lcall change_AMPM
0239            295                    done_hours:
0239 22         296                    ret
023A            297            
023A            298   ;---------------------------------;
023A            299   ; Main program. Includes hardware ;
023A            300   ; initialization and 'forever'    ;
023A            301   ; loop.                           ;
023A            302   ;---------------------------------;
023A            303   main:
023A            304            ; Initialization
023A 75817F     305       mov SP, #0x7F
023D 1200FF     306       lcall Timer0_Init
0240 12011B     307       lcall Timer2_Init
0243            308       ; In case you decide to use the pins of P0, configure the port in bidirectional mode:
0243 75E600     309       mov P0M0, #0
0246 75E700     310       mov P0M1, #0
0249 D2C5       311       setb p4.5
024B D2AF       312       setb EA   ; Enable Global interrupts
024D 120088     313       lcall LCD_4BIT
0250            314       ; For convenience a few handy macros are included in 'LCD_4bit.inc':
0250 C0E0       315            push acc
0252 7401       315            mov a, #1
0254 14         315            dec a
0255 1200BF     315            lcall ?Set_Cursor_1 ; Select column and row
0258 D0E0       315            pop acc
025A C083       316            push dph
025C C082       316            push dpl
025E C0E0       316            push acc
0260 9000DA     316            mov dptr, #Time_Message
0263 1200B2     316            lcall ?Send_Constant_String
0266 D0E0       316            pop acc
0268 D082       316            pop dpl
026A D083       316            pop dph
026C C0E0       317            push acc
026E 7401       317            mov a, #1
0270 14         317            dec a
0271 1200BD     317            lcall ?Set_Cursor_2 ; Select column and row
0274 D0E0       317            pop acc
0276 C083       318            push dph
0278 C082       318            push dpl
027A C0E0       318            push acc
027C 9000EA     318            mov dptr, #Alarm_Message
027F 1200B2     318            lcall ?Send_Constant_String
0282 D0E0       318            pop acc
0284 D082       318            pop dpl
0286 D083       318            pop dph
0288 C0E0       319            push acc
028A 7410       319            mov a, #16
028C 14         319            dec a
028D 1200BF     319            lcall ?Set_Cursor_1 ; Select column and row
0290 D0E0       319            pop acc
0292 C0E0       320            push acc
0294 7441       320            mov a, #'A'
0296 12007E     320            lcall ?WriteData
0299 D0E0       320            pop acc
029B C0E0       321            push acc
029D 740C       321            mov a, #12
029F 14         321            dec a
02A0 1200BD     321            lcall ?Set_Cursor_2 ; Select column and row
02A3 D0E0       321            pop acc
02A5 C0E0       322            push acc
02A7 7441       322            mov a, #'A'
02A9 12007E     322            lcall ?WriteData
02AC D0E0       322            pop acc
02AE C0E0       323            push acc
02B0 740E       323            mov a, #14
02B2 14         323            dec a
02B3 1200BD     323            lcall ?Set_Cursor_2 ; Select column and row
02B6 D0E0       323            pop acc
02B8 C083       324            push dph
02BA C082       324            push dpl
02BC C0E0       324            push acc
02BE 9000FB     324            mov dptr, #Alarm_off
02C1 1200B2     324            lcall ?Send_Constant_String
02C4 D0E0       324            pop acc
02C6 D082       324            pop dpl
02C8 D083       324            pop dph ; initially display that the alarm is turned off
02CA D200       325       setb one_second_flag
02CC D201       326       setb AMPM_flag
02CE D203       327       setb AMPM_flag_A
02D0 D204       328       setb AMPM_flag_A_set
02D2 C202       329       clr Alarm_Clock_flag ; alarm clock flag initially set to zero
02D4 C205       330       clr Alarm_mode ; alarm should be automatically set to off
02D6 C206       331       clr Alarm_active ; make sure alarm is not active
02D8 753200     332            mov seconds, #0x00 ;initialize seconds to zero
02DB 753300     333            mov minutes, #0x00 ;initialize minutes to zero
02DE 753401     334            mov hours, #0x01 ;initialize hours to 1
02E1 753500     335            mov minutes_A, #0x00
02E4 753601     336            mov hours_A, #0x01
02E7            337   
02E7            338   Alarm_OnOff: ; defaults to alarm OFF after passing through the main initialization loop
02E7 30024C     339            jnb Alarm_Clock_flag, loop ; if we enter here after main, makes sure alarm is kept off and skip to loop
02EA 300523     340            jnb Alarm_mode, turn_A_on ; if Alarm_mode is zero (off) we want to turn it on
02ED B205       341                    cpl Alarm_mode ; else, we turn off Alarm_mode
02EF C0E0       342            push acc
02F1 740E       342            mov a, #14
02F3 14         342            dec a
02F4 1200BD     342            lcall ?Set_Cursor_2 ; Select column and row
02F7 D0E0       342            pop acc
02F9 C083       343            push dph
02FB C082       343            push dpl
02FD C0E0       343            push acc
02FF 9000FB     343            mov dptr, #Alarm_Off
0302 1200B2     343            lcall ?Send_Constant_String
0305 D0E0       343            pop acc
0307 D082       343            pop dpl
0309 D083       343            pop dph ; write 'off' in the alarm field
030B 200622     344                    jb Alarm_active, turn_off_alarm ; if the alarm is actively sounding, we want to turn it off once we turn off Alarm_mode
030E 8058       345                    sjmp check_hours_push ; jump back to the next stage in our button daisy chain
0310            346            turn_A_on:
0310 B205       347                    cpl Alarm_mode ; set Alarm_mode to 1
0312 C0E0       348            push acc
0314 740E       348            mov a, #14
0316 14         348            dec a
0317 1200BD     348            lcall ?Set_Cursor_2 ; Select column and row
031A D0E0       348            pop acc
031C C083       349            push dph
031E C082       349            push dpl
0320 C0E0       349            push acc
0322 9000F7     349            mov dptr, #Alarm_On
0325 1200B2     349            lcall ?Send_Constant_String
0328 D0E0       349            pop acc
032A D082       349            pop dpl
032C D083       349            pop dph ; write 'on' in the alarm field
032E 8038       350                    sjmp check_hours_push ; jump back to the next stage in our button daisy chain
0330            351   turn_off_alarm: ; sub-routine that turns off the active alarm by complementing the ET0 (timer 0 interrupt)
0330 C2A9       352            clr ET0 ; turn off timer_0 interrupt, which will stop the noise
0332 C206       353            clr Alarm_active ; turn off the active alarm flag
0334 8032       354            sjmp check_hours_push ; resume button checking
0336            355   loop: ; After initialization the program stays in this 'forever' loop
0336 20802F     356            jb SECONDS_BUTTON, check_hours_push  ; if the 'BOOT' button is not pressed goto loop_a
0339 C002       357            push AR2
033B 7A32       357            mov R2, #50
033D 120039     357            lcall ?Wait_Milli_Seconds
0340 D002       357            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0342 208023     358            jb SECONDS_BUTTON, check_hours_push  ; if the 'BOOT' button is not pressed, goto loop_a 
0345 3080FD     359            jnb SECONDS_BUTTON, $     
0348 20029C     360            jb Alarm_Clock_flag, Alarm_OnOff ; if we are in alarm mode and the seconds button is pressed, toggle alarm on/off
034B            361   second_push: ; change second value from p0.0 pushbutton
034B 1201F1     362            lcall Update_Seconds ; increments seconds by 1
034E B46067     363            cjne a, #0x60, loop_b ; if seconds != 60, display all time values
0351 753200     364            mov seconds, #0x00
0354 1201F9     365            lcall Update_Minutes ; else, reset seconds to 0 and update minutes
0357 B4605E     366            cjne a, #0x60, loop_b ; if minutes != 60, display all time values
035A 120215     367            lcall Update_Hours ; else, update the hours and reset minutes to 0
035D B41358     368            cjne a, #0x13, loop_b ; check if hours was at 12:00 when we reached 60 minutes(if not, goto Timer2_ISR_done)
0360 753401     369            mov hours, #0x01 ; reset hours back to 1:00 if it was at 12:00 when we reached 60 minutes
0363 120159     370            lcall change_AMPM
0366 8050       371            sjmp loop_b             ; Display the new value
0368            372   check_hours_push: ; change hour value from p0.6 pushbutton
0368 208622     373            jb HOURS_BUTTON, check_minutes_push  ; if the 'BOOT' button is not pressed goto loop_a
036B C002       374            push AR2
036D 7A32       374            mov R2, #50
036F 120039     374            lcall ?Wait_Milli_Seconds
0372 D002       374            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0374 208616     375            jb HOURS_BUTTON, check_minutes_push  ; if the 'BOOT' button is not pressed, goto loop_a 
0377 3086FD     376            jnb HOURS_BUTTON, $        
037A            377   hour_push:
037A 120215     378            lcall Update_Hours
037D E534       379            mov a, hours
037F B41336     380            cjne a, #0x13, loop_b
0382 753401     381            mov hours, #0x01
0385            382            ;lcall change_AMPM
0385 8031       383            sjmp loop_b
0387            384   loop_a: ; maximum distance from loop label for jnb to work
0387 3000AC     385            jnb one_second_flag, loop
038A 0203B8     386            ljmp loop_b
038D            387   check_minutes_push: ; change minute values from p0.3 pushbutton
038D 208330     388            jb MINUTES_BUTTON, check_AMPM_push  ; if the 'BOOT' button is not pressed goto loop_a
0390 C002       389            push AR2
0392 7A32       389            mov R2, #50
0394 120039     389            lcall ?Wait_Milli_Seconds
0397 D002       389            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
0399 208324     390            jb MINUTES_BUTTON, check_AMPM_push  ; if the 'BOOT' button is not pressed, goto loop_a 
039C 3083FD     391            jnb MINUTES_BUTTON, $      
039F            392   minute_push:
039F 1201F9     393            lcall Update_Minutes
03A2 E533       394            mov a, minutes
03A4 B46011     395            cjne a, #0x60, loop_b
03A7 753300     396            mov minutes, #0x00
03AA 120215     397            lcall Update_Hours
03AD B41308     398            cjne a, #0x13, loop_b
03B0 753401     399            mov hours, #0x01
03B3 120159     400            lcall change_AMPM
03B6 8000       401            sjmp loop_b
03B8            402            
03B8            403   ; we should control whether or not we change the clock vs. alarm digits in this loop
03B8            404   ; probably need to have an alarm flag (on/off) that will control which line we edit (clock/alarm)
03B8            405   ; we also probably need seperate counters for minutes and hours
03B8            406   loop_b: ;if one_second flag is high or we have reset the clock values, we enter this loop
03B8 C200       407       clr one_second_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
03BA 1203EF     408       lcall write_times ; prints all times to the display
03BD 020336     409       ljmp loop
03C0            410      
03C0            411   check_AMPM_push: ; change between AM/PM using p4.5 pushbutton
03C0 20C514     412            jb AMPM_BUTTON, check_mode_push  ; if the 'BOOT' button is not pressed goto loop_a
03C3 C002       413            push AR2
03C5 7A32       413            mov R2, #50
03C7 120039     413            lcall ?Wait_Milli_Seconds
03CA D002       413            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03CC 20C508     414            jb AMPM_BUTTON, check_mode_push  ; if the 'BOOT' button is not pressed, goto loop_a 
03CF 30C5FD     415            jnb AMPM_BUTTON, $         ; Wait for button release.  The '$' means: jump to same instruction
03D2            416   AMPM_push:
03D2 120159     417            lcall change_AMPM
03D5 80E1       418            sjmp loop_b
03D7            419   check_mode_push: ; change between clock/alarm value editing mode using p2.1 pushbutton
03D7 20A1AD     420            jb CLOCK_MODE, loop_a  ; if the 'BOOT' button is not pressed goto loop_a
03DA C002       421            push AR2
03DC 7A32       421            mov R2, #50
03DE 120039     421            lcall ?Wait_Milli_Seconds
03E1 D002       421            pop AR2         ; Debounce delay.  This macro is also in 'LCD_4bit.inc'
03E3 20A1A1     422            jb CLOCK_MODE, loop_a  ; if the 'BOOT' button is not pressed, goto loop_a 
03E6 30A1FD     423            jnb CLOCK_MODE, $          ; Wait for button release.  The '$' means: jump to same instruction
03E9            424   mode_push:
03E9 B202       425            cpl Alarm_Clock_flag ; triggers if we switch to "alarm" or "clock" editing mode
03EB B203       426            cpl AMPM_flag_A ; flag to allow us to control the AM and PM setting in the ALARM row
03ED            427            ;cpl ET2  ; Disable/Enable timer 2 interrupt
03ED 80C9       428            sjmp loop_b
03EF            429   write_times: ; label to write all relevant time values to the LCD
03EF C0E0       430            push acc
03F1 740D       430            mov a, #13
03F3 14         430            dec a
03F4 1200BF     430            lcall ?Set_Cursor_1 ; Select column and row
03F7 D0E0       430            pop acc     ; the place in the LCD where we want the BCD counter value
03F9 C000       431            push ar0
03FB A832       431            mov r0, seconds
03FD 1200C4     431            lcall ?Display_BCD
0400 D000       431            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0402 C0E0       432            push acc
0404 740A       432            mov a, #10
0406 14         432            dec a
0407 1200BF     432            lcall ?Set_Cursor_1 ; Select column and row
040A D0E0       432            pop acc
040C C000       433            push ar0
040E A833       433            mov r0, minutes
0410 1200C4     433            lcall ?Display_BCD
0413 D000       433            pop ar0
0415 C0E0       434            push acc
0417 7407       434            mov a, #7
0419 14         434            dec a
041A 1200BF     434            lcall ?Set_Cursor_1 ; Select column and row
041D D0E0       434            pop acc
041F C000       435            push ar0
0421 A834       435            mov r0, hours
0423 1200C4     435            lcall ?Display_BCD
0426 D000       435            pop ar0
0428 C0E0       436            push acc
042A 7407       436            mov a, #7
042C 14         436            dec a
042D 1200BD     436            lcall ?Set_Cursor_2 ; Select column and row
0430 D0E0       436            pop acc
0432 C000       437            push ar0
0434 A836       437            mov r0, hours_A
0436 1200C4     437            lcall ?Display_BCD
0439 D000       437            pop ar0
043B C0E0       438            push acc
043D 740A       438            mov a, #10
043F 14         438            dec a
0440 1200BD     438            lcall ?Set_Cursor_2 ; Select column and row
0443 D0E0       438            pop acc
0445 C000       439            push ar0
0447 A835       439            mov r0, minutes_A
0449 1200C4     439            lcall ?Display_BCD
044C D000       439            pop ar0
044E 22         440            ret
044F            441   END
